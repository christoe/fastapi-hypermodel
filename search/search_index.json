{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI-HyperModel","text":"<p> Simple hypermedia for FastAPI </p> <p> </p> <p>Documentation: https://jtc42.github.io/fastapi-hypermodel/</p> <p>Source Code: https://github.com/jtc42/fastapi-hypermodel</p> <p>FastAPI-HyperModel is a FastAPI + Pydantic extension for simplifying hypermedia-driven API development. </p> <p>This module adds a new Pydantic model base-class, supporting dynamic <code>href</code> generation based on object data.</p> Model Response <pre><code>class ItemSummary(HyperModel):\nname: str\nid: str\nhref = UrlFor(\n\"read_item\", {\"item_id\": \"&lt;id&gt;\"}\n)\n</code></pre> <pre><code>{\n\"name\": \"Foo\",\n\"id\": \"item01\",\n\"href\": \"/items/item01\"\n}\n</code></pre> <pre><code>class ItemSummary(HyperModel):\nname: str\nid: str\nlink = HALFor(\n\"read_item\", {\"item_id\": \"&lt;id&gt;\"}, \ndescription=\"Read an item\"\n)\n</code></pre> <pre><code>{\n\"name\": \"Foo\",\n\"id\": \"item01\",\n\"link\": {\n\"href\": \"/items/item01\",\n\"method\": \"GET\",\n\"description\": \"Read an item\"\n}\n}\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install fastapi-hypermodel</code></p>"},{"location":"#limitations","title":"Limitations","text":"<p>Currently, query parameters will not resolve correctly. When generating a resource URL, ensure all parameters passed are path parameters, not query parameters.</p> <p>This is an upstream issue, being tracked here.</p>"},{"location":"#attributions","title":"Attributions","text":"<p>Some functionality is based on Flask-Marshmallow <code>URLFor</code> class.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#conditional-links","title":"Conditional Links","text":"<p>It is possible to add additional field-value-dependent conditions on links. For example, you may want certain links within a set to only appear if the application or session is in a state that allows that interaction.</p> <p>Let's begin with our <code>Person</code> example from earlier.</p> <pre><code>class Person(HyperModel):\nid: str\nname: str\nitems: List[ItemSummary]\nhref = UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"})\nlinks = LinkSet(\n{\n\"self\": UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"}),\n\"items\": UrlFor(\"read_person_items\", {\"person_id\": \"&lt;id&gt;\"}),\n}\n)\n</code></pre> <p>We may want a new link that corresponds to adding a new Item to the Person.</p> <pre><code>class Person(HyperModel):\nid: str\nname: str\nitems: List[ItemSummary]\nhref = UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"})\nlinks = LinkSet(\n{\n\"self\": UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"}),\n\"items\": UrlFor(\"read_person_items\", {\"person_id\": \"&lt;id&gt;\"}),\n\"addItem\": UrlFor(\"put_person_items\", {\"person_id\": \"&lt;id&gt;\"},),\n}\n)\n</code></pre> <p>However, we may want functionality where a Person can be \"locked\", and no new items added. We add a new field <code>is_locked</code> to our model.</p> <pre><code>class Person(HyperModel):\nid: str\nname: str\nis_locked: bool\nitems: List[ItemSummary]\nhref = UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"})\nlinks = LinkSet(\n{\n\"self\": UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"}),\n\"items\": UrlFor(\"read_person_items\", {\"person_id\": \"&lt;id&gt;\"}),\n\"addItem\": UrlFor(\"put_person_items\", {\"person_id\": \"&lt;id&gt;\"},),\n}\n)\n</code></pre> <p>Now, if the Person is locked, the <code>addItem</code> link is no longer relevant. Querying it will result in a denied error, and so we may choose to remove it from the link set. To do this, we will add a field-dependent condition to the link.</p> <pre><code>class Person(HyperModel):\nid: str\nname: str\nis_locked: bool\nitems: List[ItemSummary]\nhref = UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"})\nlinks = LinkSet(\n{\n\"self\": UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"}),\n\"items\": UrlFor(\"read_person_items\", {\"person_id\": \"&lt;id&gt;\"}),\n\"addItem\": UrlFor(\n\"put_person_items\",\n{\"person_id\": \"&lt;id&gt;\"},\ncondition=lambda values: not values[\"is_locked\"],\n),\n}\n)\n</code></pre> <p>The <code>condition</code> argument takes a callable, which will be passed dict containing the name-to-value mapping of all fields on the parent <code>HyperModel</code> instance. In this example, we use a lambda function that returns <code>True</code> or <code>False</code> depending on the value <code>is_locked</code> of the parent <code>HyperModel</code> instance.</p> <p>Note</p> <p>Conditional links will always show up in the auto-generated OpenAPI/Swagger documentation. These conditions only apply to the hypermedia fields generated at runtime.</p>"},{"location":"basics/","title":"Basic Usage","text":""},{"location":"basics/#import-hypermodel-and-optionally-hyperref","title":"Import <code>HyperModel</code> and optionally <code>HyperRef</code>","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi_hypermodel import HyperModel, UrlFor, LinkSet\n</code></pre> <p><code>HyperModel</code> will be your model base-class.</p>"},{"location":"basics/#create-your-basic-models","title":"Create your basic models","text":"<p>We'll create two models, a brief item summary including ID, name, and a link, and a full model containing additional information. We'll use <code>ItemSummary</code> in our item list, and <code>ItemDetail</code> for full item information.</p> <pre><code>class ItemSummary(HyperModel):\nid: str\nname: str\nclass ItemDetail(ItemSummary):\ndescription: Optional[str] = None\nprice: float\nclass Person(HyperModel):\nname: str\nid: str\nitems: List[ItemSummary]\n</code></pre>"},{"location":"basics/#create-and-attach-your-app","title":"Create and attach your app","text":"<p>We'll now create our FastAPI app, and bind it to our <code>HyperModel</code> base class.</p> <pre><code>from fastapi import FastAPI\napp = FastAPI()\nHyperModel.init_app(app)\n</code></pre>"},{"location":"basics/#add-some-api-views","title":"Add some API views","text":"<p>We'll create an API view for a list of items, as well as details about an individual item. Note that we pass the item ID with our <code>{item_id}</code> URL variable.</p> <pre><code>@app.get(\"/items\", response_model=List[ItemSummary])\ndef read_items():\nreturn list(items.values())\n@app.get(\"/items/{item_id}\", response_model=ItemDetail)\ndef read_item(item_id: str):\nreturn items[item_id]\n@app.get(\"/people/{person_id}\", response_model=Person)\ndef read_person(person_id: str):\nreturn people[person_id]\n@app.get(\"/people/{person_id}/items\", response_model=List[ItemDetail])\ndef read_person_items(person_id: str):\nreturn people[person_id][\"items\"]\n</code></pre>"},{"location":"basics/#create-a-model-href","title":"Create a model <code>href</code>","text":"<p>We'll now go back and add an <code>href</code> field with a special <code>UrlFor</code> value. This <code>UrlFor</code> class defines how our href elements will be generated. We'll change our <code>ItemSummary</code> class to:</p> <pre><code>class ItemSummary(HyperModel):\nname: str\nid: str\nhref = UrlFor(\"read_item\", {\"item_id\": \"&lt;id&gt;\"})\n</code></pre> <p>The <code>UrlFor</code> class takes two arguments:</p>"},{"location":"basics/#endpoint","title":"<code>endpoint</code>","text":"<p>Name of your FastAPI endpoint function you want to link to. In our example, we want our item summary to link to the corresponding item detail page, which maps to our <code>read_item</code> function.</p> <p>Alternatively, rather than providing the endpoint name, you can provide a reference to the endpoint function itself, for example <code>UrlFor(read_item, {\"item_id\": \"&lt;id&gt;\"})</code>. This can help with larger projects where function names may be refactored.</p>"},{"location":"basics/#values-optional-depending-on-endpoint","title":"<code>values</code> (optional depending on endpoint)","text":"<p>Same keyword arguments as FastAPI's url_path_for, except string arguments enclosed in &lt; &gt; will be interpreted as attributes to pull from the object. For example, here we need to pass an <code>item_id</code> argument as required by our endpoint function, and we want to populate that with our item object's <code>id</code> attribute.</p>"},{"location":"basics/#create-a-link-set","title":"Create a link set","text":"<p>In some cases we want to create a map of relational links. In these cases we can create a <code>LinkSet</code> field describing each link and it's relationship to the object. The <code>LinkSet</code> class is really just a spicy dictionary that tells the parent <code>HyperModel</code> to \"render\" each link in the link set, and includes some extra OpenAPI schema stuff.</p> <pre><code>class Person(HyperModel):\nid: str\nname: str\nitems: List[ItemSummary]\nhref = UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"})\nlinks = LinkSet(\n{\n\"self\": UrlFor(\"read_person\", {\"person_id\": \"&lt;id&gt;\"}),\n\"items\": UrlFor(\"read_person_items\", {\"person_id\": \"&lt;id&gt;\"}),\n}\n)\n</code></pre>"},{"location":"basics/#putting-it-all-together","title":"Putting it all together","text":"<p>For this example, we can make a dictionary containing some fake data, and add extra models, even nesting models if we want. A complete example based on this documentation can be found here.</p> <p>If we run the example application and go to our <code>/items</code> URL, we should get a response like:</p> <pre><code>[\n{\n\"name\": \"Foo\",\n\"id\": \"item01\",\n\"href\": \"/items/item01\"\n},\n{\n\"name\": \"Bar\",\n\"id\": \"item02\",\n\"href\": \"/items/item02\"\n},\n{\n\"name\": \"Baz\",\n\"id\": \"item03\",\n\"href\": \"/items/item03\"\n}\n]\n</code></pre>"},{"location":"extending/","title":"Extending FastAPI-HyperModel","text":"<p>The <code>HyperModel</code> class works by adding a root validator that iterates through each field on the instance being validated, and checks if it is an instance of <code>AbstractHyperField</code>.</p> <p>If an instance of <code>AbstractHyperField</code> is found, its <code>__build_hypermedia__</code> method is called, and the returned value will be substituted into the validated <code>HyperModel</code> instance.</p>"},{"location":"extending/#creating-a-new-link-class","title":"Creating a new link class","text":"<p>In most respects, a custom link class should be treated as a custom Pydantic data type. It can inherit from any Pydantic-compatible type, include any custom validation required, but must also inherit from <code>AbstractHyperField</code> and include a <code>__build_hypermedia__</code> method.</p> <p>This method must accept two arguments, an optional <code>fastapi.FastAPI</code> instance (optional only because prior to <code>HyperModel.init_app</code> being called, it will evaluate to <code>None</code>), and a dict containing the name-to-value mapping of all fields on the parent <code>HyperModel</code> instance.</p> <p>As an example, we'll re-implement the basic <code>URLFor</code> class from scratch.</p>"},{"location":"extending/#create-a-basic-custom-pydantic-class","title":"Create a basic custom Pydantic class","text":"<p>First we'll create a subclass of <code>UrlType</code> which accepts an endpoint string, and a dictionary of URL parameter to field mappings (see Basic Usage).</p> <pre><code>from fastapi_hypermodel.hypermodel import UrlType\nclass UrlFor(UrlType):\ndef __init__(self, endpoint: str, param_values: Optional[Dict[str, str]] = None):\nself.endpoint: str = endpoint\nself.param_values: Dict[str, str] = param_values or {}\nsuper().__init__()\n</code></pre> <p>Next, we'll add out basic Pydantic validation functionality:</p> <pre><code>from fastapi_hypermodel.hypermodel import UrlType\nfrom starlette.datastructures import URLPath\nclass UrlFor(UrlType):\ndef __init__(self, endpoint: str, param_values: Optional[Dict[str, str]] = None):\nself.endpoint: str = endpoint\nself.param_values: Dict[str, str] = param_values or {}\nsuper().__init__()\n@no_type_check\ndef __new__(cls, *_):\nreturn str.__new__(cls)\n@classmethod\ndef __get_validators__(cls):\nyield cls.validate\n@classmethod\ndef validate(cls, value: Any) -&gt; \"UrlFor\":\n\"\"\"\n        Validate UrlFor object against itself.\n        The UrlFor field type will only accept UrlFor instances.\n        \"\"\"\n# Return original object if it's already a UrlFor instance\nif value.__class__ == URLPath:\nreturn value\n# Otherwise raise an exception\nraise ValueError(\nf\"UrlFor field should resolve to a starlette.datastructures.URLPath instance. Instead got {value.__class__}\"\n)\n</code></pre> <p>At this point, our custom type will behave as a normal Pydantic type, but won't do any hypermedia substitutions. For this, we must add our \"magic\" <code>__build_hypermedia__</code> method.</p> <pre><code>from fastapi_hypermodel.hypermodel import UrlType, resolve_param_values\nfrom starlette.datastructures import URLPath\nclass UrlFor(UrlType, AbstractHyperField):\ndef __init__(self, endpoint: str, param_values: Optional[Dict[str, str]] = None):\nself.endpoint: str = endpoint\nself.param_values: Dict[str, str] = param_values or {}\nsuper().__init__()\n@no_type_check\ndef __new__(cls, *_):\nreturn str.__new__(cls)\n@classmethod\ndef __get_validators__(cls):\nyield cls.validate\n@classmethod\ndef validate(cls, value: Any) -&gt; \"UrlFor\":\n\"\"\"\n        Validate UrlFor object against itself.\n        The UrlFor field type will only accept UrlFor instances.\n        \"\"\"\n# Return original object if it's already a UrlFor instance\nif value.__class__ == URLPath:\nreturn value\n# Otherwise raise an exception\nraise ValueError(\nf\"UrlFor field should resolve to a starlette.datastructures.URLPath instance. Instead got {value.__class__}\"\n)\ndef __build_hypermedia__(\nself, app: Optional[FastAPI], values: Dict[str, Any]\n) -&gt; Optional[str]:\nif app is None:\nreturn None\nresolved_params = resolve_param_values(self.param_values, values)\nreturn app.url_path_for(self.endpoint, **resolved_params)\n</code></pre> <p>Here we see that, as expected, our method accepts a <code>FastAPI</code> instance, and our dict of parent field values. We pass these field values, along with the URL parameter to field mappings, to a <code>resolve_param_values</code> function. This function takes our URL parameter to field mappings, and substitutes in the actual values from the parent. </p> <p>We can then pass this new dictionary of URL parameters to the FastAPI <code>url_path_for</code> function to generate a valid URL for this specific endpoint with this specific set of values.</p>"},{"location":"extending/#creating-a-new-link-set-class","title":"Creating a new link set class","text":"<p>In FastAPI-HyperModel, a link set is essentially just another subclass of <code>AbstractHyperField</code>. The dictionary of returned links is generated by recursively calling <code>__build_hypermedia__</code> for each item, in the <code>__build_hypermedia__</code> method of the link set itself.</p> <p>This is most easily explained by analysing the source code for the built-in <code>LinkSet</code> class.</p> <pre><code>_LinkSetType = Dict[str, AbstractHyperField]\nclass LinkSet(_LinkSetType, AbstractHyperField):  # pylint: disable=too-many-ancestors\n@classmethod\ndef __get_validators__(cls):\nyield dict_validator\n@classmethod\ndef __modify_schema__(cls, field_schema: Dict[str, Any]) -&gt; None:\nfield_schema.update({\"additionalProperties\": _uri_schema})\ndef __build_hypermedia__(\nself, app: Optional[FastAPI], values: Dict[str, Any]\n) -&gt; Dict[str, str]:\nreturn {k: u.__build_hypermedia__(app, values) for k, u in self.items()}  # type: ignore  # pylint: disable=no-member\n</code></pre> <p>This class behaves link a standard dictionary, with <code>str</code> keys and any other <code>AbstractHyperField</code> as values. This allows, for example, nesting <code>LinkSet</code> instances for rich, deep hypermedia, as well as allowing different hypermedia types (such as <code>HALFor</code> links). </p> <p>The <code>__get_validators__</code> and <code>__modify_schema__</code> handle standard Pydantic functionality. Within <code>__build_hypermedia__</code>, we simply return a dictionary of key-value pairs, where each value is generated by calling the item's <code>__build_hypermedia__</code> method.</p> <p>By overriding this method, it's possible to create entirely new formats of link sets as required.</p>"}]}